import { Observable, Subscription } from 'rxjs';
import { OnDestroy, InjectionToken } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export interface SelectConfig {
    debounce?: boolean;
}
export declare const initialStateToken: InjectionToken<unknown>;
export declare class ComponentStore<T extends object> implements OnDestroy {
    private readonly destroySubject$;
    readonly destroy$: Observable<void>;
    private readonly stateSubject$;
    private isInitialized;
    private notInitializedErrorMessage;
    readonly state$: Observable<T>;
    constructor(defaultState?: T);
    /** Completes all relevant Observable streams. */
    ngOnDestroy(): void;
    /**
     * Creates an updater.
     *
     * Throws an error if updater is called with synchronous values (either
     * imperative value or Observable that is synchronous) before ComponentStore
     * is initialized. If called with async Observable before initialization then
     * state will not be updated and subscription would be closed.
     *
     * @param updaterFn A static updater function that takes 2 parameters (the
     * current state and an argument object) and returns a new instance of the
     * state.
     * @return A function that accepts one argument which is forwarded as the
     *     second argument to `updaterFn`. Every time this function is called
     *     subscribers will be notified of the state change.
     */
    updater<V>(updaterFn: (state: T, value: V) => T): unknown extends V ? () => void : (t: V | Observable<V>) => Subscription;
    /**
     * Initializes state. If it was already initialized then it resets the
     * state.
     */
    private initState;
    /**
     * Sets the state specific value.
     * @param stateOrUpdaterFn object of the same type as the state or an
     * updaterFn, returning such object.
     */
    setState(stateOrUpdaterFn: T | ((state: T) => T)): void;
    protected get(): T;
    protected get<R>(projector: (s: T) => R): R;
    /**
     * Creates a selector.
     *
     * This supports combining up to 4 selectors. More could be added as needed.
     *
     * @param projector A pure projection function that takes the current state and
     *   returns some new slice/projection of that state.
     * @param config SelectConfig that changes the behavior of selector, including
     *   the debouncing of the values until the state is settled.
     * @return An observable of the projector results.
     */
    select<R>(projector: (s: T) => R, config?: SelectConfig): Observable<R>;
    select<R, S1>(s1: Observable<S1>, projector: (s1: S1) => R, config?: SelectConfig): Observable<R>;
    select<R, S1, S2>(s1: Observable<S1>, s2: Observable<S2>, projector: (s1: S1, s2: S2) => R, config?: SelectConfig): Observable<R>;
    select<R, S1, S2, S3>(s1: Observable<S1>, s2: Observable<S2>, s3: Observable<S3>, projector: (s1: S1, s2: S2, s3: S3) => R, config?: SelectConfig): Observable<R>;
    select<R, S1, S2, S3, S4>(s1: Observable<S1>, s2: Observable<S2>, s3: Observable<S3>, s4: Observable<S4>, projector: (s1: S1, s2: S2, s3: S3, s4: S4) => R, config?: SelectConfig): Observable<R>;
    /**
     * Creates an effect.
     *
     * This effect is subscribed to for the life of the @Component.
     * @param generator A function that takes an origin Observable input and
     *     returns an Observable. The Observable that is returned will be
     *     subscribed to for the life of the component.
     * @return A function that, when called, will trigger the origin Observable.
     */
    effect<ProvidedType = void, OriginType extends Observable<ProvidedType> | unknown = Observable<ProvidedType>, ObservableType = OriginType extends Observable<infer A> ? A : never, ReturnType = ProvidedType | ObservableType extends void ? () => void : (observableOrValue: ObservableType | Observable<ObservableType>) => Subscription>(generator: (origin$: OriginType) => Observable<unknown>): ReturnType;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ComponentStore<any>, [{ optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<ComponentStore<any>>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LXN0b3JlLmQudHMiLCJzb3VyY2VzIjpbImNvbXBvbmVudC1zdG9yZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgT25EZXN0cm95LCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RDb25maWcge1xuICAgIGRlYm91bmNlPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IGluaXRpYWxTdGF0ZVRva2VuOiBJbmplY3Rpb25Ub2tlbjx1bmtub3duPjtcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENvbXBvbmVudFN0b3JlPFQgZXh0ZW5kcyBvYmplY3Q+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlc3Ryb3lTdWJqZWN0JDtcbiAgICByZWFkb25seSBkZXN0cm95JDogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0YXRlU3ViamVjdCQ7XG4gICAgcHJpdmF0ZSBpc0luaXRpYWxpemVkO1xuICAgIHByaXZhdGUgbm90SW5pdGlhbGl6ZWRFcnJvck1lc3NhZ2U7XG4gICAgcmVhZG9ubHkgc3RhdGUkOiBPYnNlcnZhYmxlPFQ+O1xuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRTdGF0ZT86IFQpO1xuICAgIC8qKiBDb21wbGV0ZXMgYWxsIHJlbGV2YW50IE9ic2VydmFibGUgc3RyZWFtcy4gKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gdXBkYXRlci5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB1cGRhdGVyIGlzIGNhbGxlZCB3aXRoIHN5bmNocm9ub3VzIHZhbHVlcyAoZWl0aGVyXG4gICAgICogaW1wZXJhdGl2ZSB2YWx1ZSBvciBPYnNlcnZhYmxlIHRoYXQgaXMgc3luY2hyb25vdXMpIGJlZm9yZSBDb21wb25lbnRTdG9yZVxuICAgICAqIGlzIGluaXRpYWxpemVkLiBJZiBjYWxsZWQgd2l0aCBhc3luYyBPYnNlcnZhYmxlIGJlZm9yZSBpbml0aWFsaXphdGlvbiB0aGVuXG4gICAgICogc3RhdGUgd2lsbCBub3QgYmUgdXBkYXRlZCBhbmQgc3Vic2NyaXB0aW9uIHdvdWxkIGJlIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cGRhdGVyRm4gQSBzdGF0aWMgdXBkYXRlciBmdW5jdGlvbiB0aGF0IHRha2VzIDIgcGFyYW1ldGVycyAodGhlXG4gICAgICogY3VycmVudCBzdGF0ZSBhbmQgYW4gYXJndW1lbnQgb2JqZWN0KSBhbmQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGVcbiAgICAgKiBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBhcmd1bWVudCB3aGljaCBpcyBmb3J3YXJkZWQgYXMgdGhlXG4gICAgICogICAgIHNlY29uZCBhcmd1bWVudCB0byBgdXBkYXRlckZuYC4gRXZlcnkgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgICAqICAgICBzdWJzY3JpYmVycyB3aWxsIGJlIG5vdGlmaWVkIG9mIHRoZSBzdGF0ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgdXBkYXRlcjxWPih1cGRhdGVyRm46IChzdGF0ZTogVCwgdmFsdWU6IFYpID0+IFQpOiB1bmtub3duIGV4dGVuZHMgViA/ICgpID0+IHZvaWQgOiAodDogViB8IE9ic2VydmFibGU8Vj4pID0+IFN1YnNjcmlwdGlvbjtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBzdGF0ZS4gSWYgaXQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQgdGhlbiBpdCByZXNldHMgdGhlXG4gICAgICogc3RhdGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0U3RhdGU7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUgc3BlY2lmaWMgdmFsdWUuXG4gICAgICogQHBhcmFtIHN0YXRlT3JVcGRhdGVyRm4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIHN0YXRlIG9yIGFuXG4gICAgICogdXBkYXRlckZuLCByZXR1cm5pbmcgc3VjaCBvYmplY3QuXG4gICAgICovXG4gICAgc2V0U3RhdGUoc3RhdGVPclVwZGF0ZXJGbjogVCB8ICgoc3RhdGU6IFQpID0+IFQpKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgZ2V0KCk6IFQ7XG4gICAgcHJvdGVjdGVkIGdldDxSPihwcm9qZWN0b3I6IChzOiBUKSA9PiBSKTogUjtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIHN1cHBvcnRzIGNvbWJpbmluZyB1cCB0byA0IHNlbGVjdG9ycy4gTW9yZSBjb3VsZCBiZSBhZGRlZCBhcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvamVjdG9yIEEgcHVyZSBwcm9qZWN0aW9uIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGN1cnJlbnQgc3RhdGUgYW5kXG4gICAgICogICByZXR1cm5zIHNvbWUgbmV3IHNsaWNlL3Byb2plY3Rpb24gb2YgdGhhdCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFNlbGVjdENvbmZpZyB0aGF0IGNoYW5nZXMgdGhlIGJlaGF2aW9yIG9mIHNlbGVjdG9yLCBpbmNsdWRpbmdcbiAgICAgKiAgIHRoZSBkZWJvdW5jaW5nIG9mIHRoZSB2YWx1ZXMgdW50aWwgdGhlIHN0YXRlIGlzIHNldHRsZWQuXG4gICAgICogQHJldHVybiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBwcm9qZWN0b3IgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBzZWxlY3Q8Uj4ocHJvamVjdG9yOiAoczogVCkgPT4gUiwgY29uZmlnPzogU2VsZWN0Q29uZmlnKTogT2JzZXJ2YWJsZTxSPjtcbiAgICBzZWxlY3Q8UiwgUzE+KHMxOiBPYnNlcnZhYmxlPFMxPiwgcHJvamVjdG9yOiAoczE6IFMxKSA9PiBSLCBjb25maWc/OiBTZWxlY3RDb25maWcpOiBPYnNlcnZhYmxlPFI+O1xuICAgIHNlbGVjdDxSLCBTMSwgUzI+KHMxOiBPYnNlcnZhYmxlPFMxPiwgczI6IE9ic2VydmFibGU8UzI+LCBwcm9qZWN0b3I6IChzMTogUzEsIHMyOiBTMikgPT4gUiwgY29uZmlnPzogU2VsZWN0Q29uZmlnKTogT2JzZXJ2YWJsZTxSPjtcbiAgICBzZWxlY3Q8UiwgUzEsIFMyLCBTMz4oczE6IE9ic2VydmFibGU8UzE+LCBzMjogT2JzZXJ2YWJsZTxTMj4sIHMzOiBPYnNlcnZhYmxlPFMzPiwgcHJvamVjdG9yOiAoczE6IFMxLCBzMjogUzIsIHMzOiBTMykgPT4gUiwgY29uZmlnPzogU2VsZWN0Q29uZmlnKTogT2JzZXJ2YWJsZTxSPjtcbiAgICBzZWxlY3Q8UiwgUzEsIFMyLCBTMywgUzQ+KHMxOiBPYnNlcnZhYmxlPFMxPiwgczI6IE9ic2VydmFibGU8UzI+LCBzMzogT2JzZXJ2YWJsZTxTMz4sIHM0OiBPYnNlcnZhYmxlPFM0PiwgcHJvamVjdG9yOiAoczE6IFMxLCBzMjogUzIsIHMzOiBTMywgczQ6IFM0KSA9PiBSLCBjb25maWc/OiBTZWxlY3RDb25maWcpOiBPYnNlcnZhYmxlPFI+O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBlZmZlY3QgaXMgc3Vic2NyaWJlZCB0byBmb3IgdGhlIGxpZmUgb2YgdGhlIEBDb21wb25lbnQuXG4gICAgICogQHBhcmFtIGdlbmVyYXRvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gb3JpZ2luIE9ic2VydmFibGUgaW5wdXQgYW5kXG4gICAgICogICAgIHJldHVybnMgYW4gT2JzZXJ2YWJsZS4gVGhlIE9ic2VydmFibGUgdGhhdCBpcyByZXR1cm5lZCB3aWxsIGJlXG4gICAgICogICAgIHN1YnNjcmliZWQgdG8gZm9yIHRoZSBsaWZlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIHRyaWdnZXIgdGhlIG9yaWdpbiBPYnNlcnZhYmxlLlxuICAgICAqL1xuICAgIGVmZmVjdDxQcm92aWRlZFR5cGUgPSB2b2lkLCBPcmlnaW5UeXBlIGV4dGVuZHMgT2JzZXJ2YWJsZTxQcm92aWRlZFR5cGU+IHwgdW5rbm93biA9IE9ic2VydmFibGU8UHJvdmlkZWRUeXBlPiwgT2JzZXJ2YWJsZVR5cGUgPSBPcmlnaW5UeXBlIGV4dGVuZHMgT2JzZXJ2YWJsZTxpbmZlciBBPiA/IEEgOiBuZXZlciwgUmV0dXJuVHlwZSA9IFByb3ZpZGVkVHlwZSB8IE9ic2VydmFibGVUeXBlIGV4dGVuZHMgdm9pZCA/ICgpID0+IHZvaWQgOiAob2JzZXJ2YWJsZU9yVmFsdWU6IE9ic2VydmFibGVUeXBlIHwgT2JzZXJ2YWJsZTxPYnNlcnZhYmxlVHlwZT4pID0+IFN1YnNjcmlwdGlvbj4oZ2VuZXJhdG9yOiAob3JpZ2luJDogT3JpZ2luVHlwZSkgPT4gT2JzZXJ2YWJsZTx1bmtub3duPik6IFJldHVyblR5cGU7XG59XG4iXX0=